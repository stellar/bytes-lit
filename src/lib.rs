//! Bytes converts literals into an array of bytes.
//!
//! Currently supports only integer literals of unbounded size.
//!
//! The macros are intended for small byte inputs. There is no arbitrary limit,
//! but very large inputs may result in long compilation times. For large amounts
//! of bytes, store the bytes in a file and use [`include_bytes!`] instead.

mod bytes;
mod bytesmin;

use proc_macro::TokenStream;

extern crate proc_macro;

/// Bytes converts literals into an array of bytes.
///
/// Currently supports only integer literals of unbounded size.
///
/// Supported literal forms:
/// - Base 16 (hex), e.g. `0xff`
/// - Base 2 (binary), e.g. `0b11111111`
///
/// Leading zeros are preserved. Zeros on the front of the number are preserved
/// as zeros in the final bytes. For example: `0x0001` will produce `[0, 1]`.
///
/// Decimal and octal literal forms are not supported.
///
/// This macro is intended for small byte inputs. There is no arbitrary limit,
/// but very large inputs may result in long compilation times. For large
/// amounts of bytes, store the bytes in a file and use [`include_bytes!`]
/// instead.
///
/// ### Examples
///
/// ```
/// let bytes = bytes_lit::bytes!(0x1);
/// assert_eq!(bytes, [1]);
/// ```
///
/// ```
/// let bytes = bytes_lit::bytes!(0xfded3f55dec47250a52a8c0bb7038e72fa6ffaae33562f77cd2b629ef7fd424d);
/// assert_eq!(bytes, [
///     253, 237, 63, 85, 222, 196, 114, 80, 165, 42, 140, 11, 183, 3, 142, 114,
///     250, 111, 250, 174, 51, 86, 47, 119, 205, 43, 98, 158, 247, 253, 66, 77,
/// ]);
/// ```
///
/// ```
/// let bytes = bytes_lit::bytes!(0x00000000dec47250a52a8c0bb7038e72fa6ffaae33562f77cd2b629ef7fd424d);
/// assert_eq!(bytes, [
///     0, 0, 0, 0, 222, 196, 114, 80, 165, 42, 140, 11, 183, 3, 142, 114,
///     250, 111, 250, 174, 51, 86, 47, 119, 205, 43, 98, 158, 247, 253, 66, 77,
/// ]);
/// ```
#[proc_macro]
pub fn bytes(input: TokenStream) -> TokenStream {
    bytes::bytes(input.into()).into()
}

/// Bytesmin converts literals into an array of bytes of minimal size to capture
/// the value.
///
/// Currently supports only integer literals of unbounded size.
///
/// Supported literal forms:
/// - Base 16 (hex), e.g. `0xff`
/// - Base 2 (binary), e.g. `0b11111111`
///
/// Leading zeroes on integer literals are discarded and not preserved. The
/// generated byte slice is the minimal bytes required to capture the literal
/// provided.
///
/// Decimal and octal literal forms are not supported.
///
/// To preserve leading zeros, use [`bytes!`].
///
/// This macro is intended for small byte inputs. There is no arbitrary limit,
/// but very large inputs may result in long compilation times. For large
/// amounts of bytes, store the bytes in a file and use [`include_bytes!`]
/// instead.
///
/// ### Examples
///
/// ```
/// let bytes = bytes_lit::bytesmin!(0x1);
/// assert_eq!(bytes, [1]);
/// ```
///
/// ```
/// let bytes = bytes_lit::bytesmin!(0xfded3f55dec47250a52a8c0bb7038e72fa6ffaae33562f77cd2b629ef7fd424d);
/// assert_eq!(bytes, [
///     253, 237, 63, 85, 222, 196, 114, 80, 165, 42, 140, 11, 183, 3, 142, 114,
///     250, 111, 250, 174, 51, 86, 47, 119, 205, 43, 98, 158, 247, 253, 66, 77,
/// ]);
/// ```
///
/// ```
/// let bytes = bytes_lit::bytesmin!(0x00000000dec47250a52a8c0bb7038e72fa6ffaae33562f77cd2b629ef7fd424d);
/// assert_eq!(bytes, [
///     222, 196, 114, 80, 165, 42, 140, 11, 183, 3, 142, 114, 250, 111, 250,
///     174, 51, 86, 47, 119, 205, 43, 98, 158, 247, 253, 66, 77,
/// ]);
/// ```
#[proc_macro]
pub fn bytesmin(input: TokenStream) -> TokenStream {
    bytesmin::bytesmin(input.into()).into()
}
