//! Bytes converts literals into an array of bytes.
//!
//! Currently supports only integer literals of unbounded size.

mod bytes;
mod bytesmin;

use proc_macro::TokenStream;

extern crate proc_macro;

/// Bytes converts literals into an array of bytes.
///
/// Currently supports only integer literals of unbounded size.
///
/// The following integer literal forms are supported and preserve leading
/// zeros. The final byte representation always returns a consistent number of
/// bytes given the number of digits inputed.
/// - Base 16 (hex)
/// - Base 2 (binary)
///
/// For integer literal forms that preserve leading zeros, zeros on the front of
/// the number are preserved as zeros in the final bytes. For example: `0x0001`
/// will produce `[0, 1]`.
///
/// The following integer literal forms are supported and prohibit leading
/// zeros. The number of bytes returned is not based off the number of digits
/// entered.
/// - Base 10 (decimal)
/// - Base 8 (octal)
///
/// For integer literal forms that do not have consistent digit to byte lengths,
/// the number of bytes returned is the minimum number of bytes required to
/// represent the integer.
///
/// ### Examples
///
/// ```
/// let bytes = bytes_lit::bytes!(1);
/// assert_eq!(bytes, [1]);
/// ```
///
/// ```
/// let bytes = bytes_lit::bytes!(9);
/// assert_eq!(bytes, [9]);
/// ```
///
/// ```
/// let bytes = bytes_lit::bytes!(0xfded3f55dec47250a52a8c0bb7038e72fa6ffaae33562f77cd2b629ef7fd424d);
/// assert_eq!(bytes, [
///     253, 237, 63, 85, 222, 196, 114, 80, 165, 42, 140, 11, 183, 3, 142, 114,
///     250, 111, 250, 174, 51, 86, 47, 119, 205, 43, 98, 158, 247, 253, 66, 77,
/// ]);
/// ```
///
/// ```
/// let bytes = bytes_lit::bytes!(0x00000000dec47250a52a8c0bb7038e72fa6ffaae33562f77cd2b629ef7fd424d);
/// assert_eq!(bytes, [
///     0, 0, 0, 0, 222, 196, 114, 80, 165, 42, 140, 11, 183, 3, 142, 114,
///     250, 111, 250, 174, 51, 86, 47, 119, 205, 43, 98, 158, 247, 253, 66, 77,
/// ]);
/// ```
#[proc_macro]
pub fn bytes(input: TokenStream) -> TokenStream {
    bytes::bytes(input.into()).into()
}

/// Bytesmin converts literals into an array of bytes of minimal size to capture
/// the value.
///
/// Currently supports only integer literals of unbounded size.
///
/// Leading zeroes on integer literals are discarded and not preserved. The
/// generated byte slice is the minimal bytes required to capture the literal
/// provided.
///
/// To preserve leading zeros, use [`bytes!`].
///
/// ### Examples
///
/// ```
/// let bytes = bytes_lit::bytesmin!(1);
/// assert_eq!(bytes, [1]);
/// ```
///
/// ```
/// let bytes = bytes_lit::bytesmin!(9);
/// assert_eq!(bytes, [9]);
/// ```
///
/// ```
/// let bytes = bytes_lit::bytesmin!(0xfded3f55dec47250a52a8c0bb7038e72fa6ffaae33562f77cd2b629ef7fd424d);
/// assert_eq!(bytes, [
///     253, 237, 63, 85, 222, 196, 114, 80, 165, 42, 140, 11, 183, 3, 142, 114,
///     250, 111, 250, 174, 51, 86, 47, 119, 205, 43, 98, 158, 247, 253, 66, 77,
/// ]);
/// ```
///
/// ```
/// let bytes = bytes_lit::bytesmin!(0x00000000dec47250a52a8c0bb7038e72fa6ffaae33562f77cd2b629ef7fd424d);
/// assert_eq!(bytes, [
///     222, 196, 114, 80, 165, 42, 140, 11, 183, 3, 142, 114, 250, 111, 250,
///     174, 51, 86, 47, 119, 205, 43, 98, 158, 247, 253, 66, 77,
/// ]);
/// ```
#[proc_macro]
pub fn bytesmin(input: TokenStream) -> TokenStream {
    bytesmin::bytesmin(input.into()).into()
}
